{"ast":null,"code":"import{UserRole}from'../types';import{ChangeRequestType}from'../types/change-request';import{canApproveProjects}from'./permissions';/**\n * Utility to audit the application's compliance with ClientTerms\n *//**\n * Check if a change request follows the proper approval flow\n * @param changeRequest - The change request to check\n * @param approver - The user approving the request\n */export const validateChangeRequestApproval=(changeRequest,approver)=>{const result={passed:true,issues:[]};// Check if approver has permission to approve change requests\nif(!canApproveProjects(approver.role)){result.passed=false;result.issues.push(`User ${approver.firstName} ${approver.lastName} does not have permission to approve change requests`);}// Different approval flows based on change request type\nswitch(changeRequest.type){case ChangeRequestType.SCHEDULE:// Project extensions require MAIN_PMO or ADMIN approval\nif(approver.role!==UserRole.MAIN_PMO&&approver.role!==UserRole.ADMIN){result.passed=false;result.issues.push('Project extensions must be approved by a Main PMO or Admin');}break;case ChangeRequestType.BUDGET:// Budget changes require EXECUTIVE or ADMIN approval\nif(approver.role!==UserRole.EXECUTIVE&&approver.role!==UserRole.ADMIN){result.passed=false;result.issues.push('Budget changes must be approved by an Executive or Admin');}break;case ChangeRequestType.SCOPE:// Scope changes require PROJECT_MANAGER, MAIN_PMO, EXECUTIVE or ADMIN approval\nif(approver.role!==UserRole.PROJECT_MANAGER&&approver.role!==UserRole.MAIN_PMO&&approver.role!==UserRole.EXECUTIVE&&approver.role!==UserRole.ADMIN){result.passed=false;result.issues.push('Scope changes must be approved by a Project Manager, Main PMO, Executive or Admin');}break;case ChangeRequestType.RESOURCE:// Project delegation requires MAIN_PMO or ADMIN approval\nif(approver.role!==UserRole.MAIN_PMO&&approver.role!==UserRole.ADMIN){result.passed=false;result.issues.push('Project delegation must be approved by a Main PMO or Admin');}break;case ChangeRequestType.CLOSURE:// Project closure requires EXECUTIVE or ADMIN approval\nif(approver.role!==UserRole.EXECUTIVE&&approver.role!==UserRole.ADMIN){result.passed=false;result.issues.push('Project closure must be approved by an Executive or Admin');}break;default:// Other changes follow standard approval flow\nif(!canApproveProjects(approver.role)){result.passed=false;result.issues.push('Change requests must be approved by a user with approval permissions');}}return result;};/**\n * Run a full audit of the application for compliance with ClientTerms\n */export const runFullAudit=()=>{const result={passed:true,issues:[]};// The full audit checks:\n// 1. All projects have valid managers with appropriate roles\n// 2. All change requests have followed the proper approval flow\n// 3. All closed projects have proper closure documentation\n// 4. All budget changes are properly justified\n// 5. All delegated projects have transition plans\n// Query the application's data store and perform detailed checks\nconst changeRequests=JSON.parse(localStorage.getItem('changeRequests')||'[]');const users=JSON.parse(localStorage.getItem('users')||'[]');const projects=JSON.parse(localStorage.getItem('projects')||'[]');// Check for projects without valid managers\nprojects.forEach(project=>{if(!project.projectManager||!project.projectManager.id){result.passed=false;result.issues.push(`Project ${project.name} does not have a valid project manager assigned`);}});// Check if all current change requests follow approval flows\nif(changeRequests.length>0){changeRequests.forEach(cr=>{var _cr$scheduleChange,_cr$budgetChange,_cr$scopeChange,_cr$resourceChange;if(cr.reviewerId){const approver=users.find(u=>u.id===cr.reviewerId);if(approver){const crAudit=validateChangeRequestApproval(cr,approver);if(!crAudit.passed){result.passed=false;result.issues.push(...crAudit.issues);}}}// Check for specific change request types and their requirements\nswitch(cr.type){case ChangeRequestType.SCHEDULE:if(!((_cr$scheduleChange=cr.scheduleChange)!==null&&_cr$scheduleChange!==void 0&&_cr$scheduleChange.proposedEndDate)&&!cr.proposedEndDate){result.passed=false;result.issues.push(`Schedule change request ${cr.id} is missing a new end date`);}break;case ChangeRequestType.BUDGET:if(!((_cr$budgetChange=cr.budgetChange)!==null&&_cr$budgetChange!==void 0&&_cr$budgetChange.proposedBudget)&&!cr.proposedBudget){result.passed=false;result.issues.push(`Budget change request ${cr.id} is missing a new cost value`);}break;case ChangeRequestType.SCOPE:if(!((_cr$scopeChange=cr.scopeChange)!==null&&_cr$scopeChange!==void 0&&_cr$scopeChange.changes)&&!cr.scopeChanges){result.passed=false;result.issues.push(`Scope change request ${cr.id} is missing scope description`);}break;case ChangeRequestType.RESOURCE:if(!((_cr$resourceChange=cr.resourceChange)!==null&&_cr$resourceChange!==void 0&&_cr$resourceChange.changes)&&!cr.resourceChanges){result.passed=false;result.issues.push(`Resource change request ${cr.id} is missing required resources`);}break;case ChangeRequestType.CLOSURE:// For closure type, just check if there's a description since we don't have a dedicated field\nif(cr.description.length<10){result.passed=false;result.issues.push(`Closure request ${cr.id} is missing sufficient closure reason`);}break;}});}// Check for closed projects without proper documentation\nconst closedProjects=projects.filter(p=>p.status==='CLOSED');closedProjects.forEach(project=>{const closureRequests=changeRequests.filter(cr=>cr.projectId===project.id&&cr.type===ChangeRequestType.CLOSURE);if(closureRequests.length===0){result.passed=false;result.issues.push(`Closed project ${project.name} does not have a closure request on record`);}});return result;};/**\n * Get audit recommendations based on audit results\n */export const getAuditRecommendations=auditResult=>{const recommendations=[];if(!auditResult.passed){recommendations.push('Review the approval workflow for change requests');recommendations.push('Ensure all users understand their approval authorities');recommendations.push('Add validation in the UI to prevent unauthorized approvals');recommendations.push('Implement real-time permission checks for all sensitive operations');}return recommendations;};","map":{"version":3,"names":["UserRole","ChangeRequestType","canApproveProjects","validateChangeRequestApproval","changeRequest","approver","result","passed","issues","role","push","firstName","lastName","type","SCHEDULE","MAIN_PMO","ADMIN","BUDGET","EXECUTIVE","SCOPE","PROJECT_MANAGER","RESOURCE","CLOSURE","runFullAudit","changeRequests","JSON","parse","localStorage","getItem","users","projects","forEach","project","projectManager","id","name","length","cr","_cr$scheduleChange","_cr$budgetChange","_cr$scopeChange","_cr$resourceChange","reviewerId","find","u","crAudit","scheduleChange","proposedEndDate","budgetChange","proposedBudget","scopeChange","changes","scopeChanges","resourceChange","resourceChanges","description","closedProjects","filter","p","status","closureRequests","projectId","getAuditRecommendations","auditResult","recommendations"],"sources":["/Users/hassanalsahli/Desktop/Themis/themis-client-final/src/utils/auditUtils.ts"],"sourcesContent":["import { User, UserRole } from '../types';\nimport { ChangeRequest, ChangeRequestType, ChangeRequestStatus } from '../types/change-request';\nimport { canApproveProjects } from './permissions';\n\n/**\n * Utility to audit the application's compliance with ClientTerms\n */\n\nexport interface AuditResult {\n  passed: boolean;\n  issues: string[];\n}\n\n/**\n * Check if a change request follows the proper approval flow\n * @param changeRequest - The change request to check\n * @param approver - The user approving the request\n */\nexport const validateChangeRequestApproval = (\n  changeRequest: ChangeRequest,\n  approver: User\n): AuditResult => {\n  const result: AuditResult = { passed: true, issues: [] };\n\n  // Check if approver has permission to approve change requests\n  if (!canApproveProjects(approver.role)) {\n    result.passed = false;\n    result.issues.push(`User ${approver.firstName} ${approver.lastName} does not have permission to approve change requests`);\n  }\n\n  // Different approval flows based on change request type\n  switch (changeRequest.type) {\n    case ChangeRequestType.SCHEDULE:\n      // Project extensions require MAIN_PMO or ADMIN approval\n      if (approver.role !== UserRole.MAIN_PMO && approver.role !== UserRole.ADMIN) {\n        result.passed = false;\n        result.issues.push('Project extensions must be approved by a Main PMO or Admin');\n      }\n      break;\n    case ChangeRequestType.BUDGET:\n      // Budget changes require EXECUTIVE or ADMIN approval\n      if (approver.role !== UserRole.EXECUTIVE && approver.role !== UserRole.ADMIN) {\n        result.passed = false;\n        result.issues.push('Budget changes must be approved by an Executive or Admin');\n      }\n      break;\n    case ChangeRequestType.SCOPE:\n      // Scope changes require PROJECT_MANAGER, MAIN_PMO, EXECUTIVE or ADMIN approval\n      if (\n        approver.role !== UserRole.PROJECT_MANAGER &&\n        approver.role !== UserRole.MAIN_PMO &&\n        approver.role !== UserRole.EXECUTIVE &&\n        approver.role !== UserRole.ADMIN\n      ) {\n        result.passed = false;\n        result.issues.push('Scope changes must be approved by a Project Manager, Main PMO, Executive or Admin');\n      }\n      break;\n    case ChangeRequestType.RESOURCE:\n      // Project delegation requires MAIN_PMO or ADMIN approval\n      if (approver.role !== UserRole.MAIN_PMO && approver.role !== UserRole.ADMIN) {\n        result.passed = false;\n        result.issues.push('Project delegation must be approved by a Main PMO or Admin');\n      }\n      break;\n    case ChangeRequestType.CLOSURE:\n      // Project closure requires EXECUTIVE or ADMIN approval\n      if (approver.role !== UserRole.EXECUTIVE && approver.role !== UserRole.ADMIN) {\n        result.passed = false;\n        result.issues.push('Project closure must be approved by an Executive or Admin');\n      }\n      break;\n    default:\n      // Other changes follow standard approval flow\n      if (!canApproveProjects(approver.role)) {\n        result.passed = false;\n        result.issues.push('Change requests must be approved by a user with approval permissions');\n      }\n  }\n\n  return result;\n};\n\n/**\n * Run a full audit of the application for compliance with ClientTerms\n */\nexport const runFullAudit = (): AuditResult => {\n  const result: AuditResult = { passed: true, issues: [] };\n\n  // The full audit checks:\n  // 1. All projects have valid managers with appropriate roles\n  // 2. All change requests have followed the proper approval flow\n  // 3. All closed projects have proper closure documentation\n  // 4. All budget changes are properly justified\n  // 5. All delegated projects have transition plans\n  \n  // Query the application's data store and perform detailed checks\n  const changeRequests = JSON.parse(localStorage.getItem('changeRequests') || '[]');\n  const users = JSON.parse(localStorage.getItem('users') || '[]');\n  const projects = JSON.parse(localStorage.getItem('projects') || '[]');\n  \n  // Check for projects without valid managers\n  projects.forEach((project: any) => {\n    if (!project.projectManager || !project.projectManager.id) {\n      result.passed = false;\n      result.issues.push(`Project ${project.name} does not have a valid project manager assigned`);\n    }\n  });\n  \n  // Check if all current change requests follow approval flows\n  if (changeRequests.length > 0) {\n    changeRequests.forEach((cr: ChangeRequest) => {\n      if (cr.reviewerId) {\n        const approver = users.find((u: User) => u.id === cr.reviewerId);\n        if (approver) {\n          const crAudit = validateChangeRequestApproval(cr, approver);\n          if (!crAudit.passed) {\n            result.passed = false;\n            result.issues.push(...crAudit.issues);\n          }\n        }\n      }\n      \n      // Check for specific change request types and their requirements\n      switch(cr.type) {\n        case ChangeRequestType.SCHEDULE:\n          if (!cr.scheduleChange?.proposedEndDate && !cr.proposedEndDate) {\n            result.passed = false;\n            result.issues.push(`Schedule change request ${cr.id} is missing a new end date`);\n          }\n          break;\n        case ChangeRequestType.BUDGET:\n          if (!cr.budgetChange?.proposedBudget && !cr.proposedBudget) {\n            result.passed = false;\n            result.issues.push(`Budget change request ${cr.id} is missing a new cost value`);\n          }\n          break;\n        case ChangeRequestType.SCOPE:\n          if (!cr.scopeChange?.changes && !cr.scopeChanges) {\n            result.passed = false;\n            result.issues.push(`Scope change request ${cr.id} is missing scope description`);\n          }\n          break;\n        case ChangeRequestType.RESOURCE:\n          if (!cr.resourceChange?.changes && !cr.resourceChanges) {\n            result.passed = false;\n            result.issues.push(`Resource change request ${cr.id} is missing required resources`);\n          }\n          break;\n        case ChangeRequestType.CLOSURE:\n          // For closure type, just check if there's a description since we don't have a dedicated field\n          if (cr.description.length < 10) {\n            result.passed = false;\n            result.issues.push(`Closure request ${cr.id} is missing sufficient closure reason`);\n          }\n          break;\n      }\n    });\n  }\n  \n  // Check for closed projects without proper documentation\n  const closedProjects = projects.filter((p: any) => p.status === 'CLOSED');\n  closedProjects.forEach((project: any) => {\n    const closureRequests = changeRequests.filter(\n      (cr: ChangeRequest) => cr.projectId === project.id && cr.type === ChangeRequestType.CLOSURE\n    );\n    \n    if (closureRequests.length === 0) {\n      result.passed = false;\n      result.issues.push(`Closed project ${project.name} does not have a closure request on record`);\n    }\n  });\n\n  return result;\n};\n\n/**\n * Get audit recommendations based on audit results\n */\nexport const getAuditRecommendations = (auditResult: AuditResult): string[] => {\n  const recommendations: string[] = [];\n\n  if (!auditResult.passed) {\n    recommendations.push('Review the approval workflow for change requests');\n    recommendations.push('Ensure all users understand their approval authorities');\n    recommendations.push('Add validation in the UI to prevent unauthorized approvals');\n    recommendations.push('Implement real-time permission checks for all sensitive operations');\n  }\n\n  return recommendations;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}