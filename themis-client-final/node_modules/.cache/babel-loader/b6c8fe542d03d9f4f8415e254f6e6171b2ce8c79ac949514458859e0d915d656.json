{"ast":null,"code":"import api from'./api';import{mapToBackendStatus,mapToFrontendStatus}from'../utils/taskStatusMapper';// Define response interfaces\n/**\n * Service to handle task API calls with status mapping between client and server\n */export const TaskService={/**\n   * Get all tasks for a project\n   */getAllTasks:async(projectId,token)=>{try{const response=await api.tasks.getAllTasks(projectId,token);// Map the backend status to frontend status\nreturn response.data.map(task=>({...task,status:mapToFrontendStatus(task.status)}));}catch(error){console.error('Error fetching tasks:',error);throw error;}},/**\n   * Add a comment to a task\n   */addTaskComment:async(projectId,taskId,commentText,userId,token)=>{try{// In a real implementation, this would call an API endpoint\n// For now, we'll simulate it\nconst newComment={id:`comment-${Date.now()}`,taskId,text:commentText,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),author:{id:userId,firstName:'Current',// This would be populated from the API response\nlastName:'User'// Same as above\n}};// Simulate API call delay\nawait new Promise(resolve=>setTimeout(resolve,500));console.log(`Added comment to task ${taskId}:`,newComment);return newComment;}catch(error){console.error('Error adding comment:',error);throw error;}},/**\n   * Get all independent tasks (not associated with a project)\n   */getAllIndependentTasks:async token=>{try{const response=await api.tasks.getAllIndependentTasks(token);// Map the backend status to frontend status\nreturn response.data.map(task=>({...task,status:mapToFrontendStatus(task.status)}));}catch(error){console.error('Error fetching independent tasks:',error);throw error;}},/**\n   * Get a specific task by ID\n   */getTaskById:async(projectId,taskId,token)=>{try{const response=await api.tasks.getTaskById(projectId,taskId,token);// Map the backend status to frontend status\nreturn{...response.data,status:mapToFrontendStatus(response.data.status)};}catch(error){console.error('Error fetching task:',error);throw error;}},/**\n   * Get a specific independent task by ID\n   */getIndependentTaskById:async(taskId,token)=>{try{const response=await api.tasks.getIndependentTaskById(taskId,token);// Map the backend status to frontend status\nreturn{...response.data,status:mapToFrontendStatus(response.data.status)};}catch(error){console.error('Error fetching independent task:',error);throw error;}},/**\n   * Create a new task in a project\n   */createTask:async(projectId,taskData,token)=>{try{// Map the frontend status to backend status before sending\nconst backendTaskData={...taskData,status:mapToBackendStatus(taskData.status)};const response=await api.tasks.createTask(projectId,backendTaskData,token);// Map the backend status back to frontend status in the response\nreturn{...response.data,status:mapToFrontendStatus(response.data.status)};}catch(error){console.error('Error creating task:',error);throw error;}},/**\n   * Create a new independent task (not associated with any project)\n   */createIndependentTask:async(taskData,token)=>{try{// Map the frontend status to backend status before sending\nconst backendTaskData={...taskData,status:mapToBackendStatus(taskData.status)};const response=await api.tasks.createIndependentTask(backendTaskData,token);// Map the backend status back to frontend status in the response\nreturn{...response.data,status:mapToFrontendStatus(response.data.status)};}catch(error){console.error('Error creating independent task:',error);throw error;}},/**\n   * Update an existing task\n   */updateTask:async(projectId,taskId,taskData,token)=>{try{// Map the frontend status to backend status before sending\nconst backendTaskData={...taskData,status:taskData.status!==undefined?mapToBackendStatus(taskData.status):undefined};const response=await api.tasks.updateTask(projectId,taskId,backendTaskData,token);// If the API returns the updated task, map the status back\nif(response.data){return{...response.data,status:mapToFrontendStatus(response.data.status)};}// If the API doesn't return the updated task, return the original with the updated fields\nreturn{...taskData,id:taskId,projectId};}catch(error){console.error('Error updating task:',error);throw error;}},/**\n   * Update an existing independent task\n   */updateIndependentTask:async(taskId,taskData,token)=>{try{// Map the frontend status to backend status before sending\nconst backendTaskData={...taskData,status:taskData.status!==undefined?mapToBackendStatus(taskData.status):undefined};const response=await api.tasks.updateIndependentTask(taskId,backendTaskData,token);// If the API returns the updated task, map the status back\nif(response.data){return{...response.data,status:mapToFrontendStatus(response.data.status)};}// If the API doesn't return the updated task, return the original with the updated fields\nreturn{...taskData,id:taskId};}catch(error){console.error('Error updating independent task:',error);throw error;}},/**\n   * Delete a task\n   */deleteTask:async(projectId,taskId,token)=>{try{await api.tasks.deleteTask(projectId,taskId,token);}catch(error){console.error('Error deleting task:',error);throw error;}},/**\n   * Delete an independent task\n   */deleteIndependentTask:async(taskId,token)=>{try{await api.tasks.deleteIndependentTask(taskId,token);}catch(error){console.error('Error deleting independent task:',error);throw error;}}};","map":{"version":3,"names":["api","mapToBackendStatus","mapToFrontendStatus","TaskService","getAllTasks","projectId","token","response","tasks","data","map","task","status","error","console","addTaskComment","taskId","commentText","userId","newComment","id","Date","now","text","createdAt","toISOString","updatedAt","author","firstName","lastName","Promise","resolve","setTimeout","log","getAllIndependentTasks","getTaskById","getIndependentTaskById","createTask","taskData","backendTaskData","createIndependentTask","updateTask","undefined","updateIndependentTask","deleteTask","deleteIndependentTask"],"sources":["/Users/hassanalsahli/Desktop/Themis/themis-client-final/src/services/TaskService.ts"],"sourcesContent":["import api from './api';\nimport { Task, TaskStatus } from '../types';\nimport { mapToBackendStatus, mapToFrontendStatus } from '../utils/taskStatusMapper';\n\n// Define response interfaces\ninterface ApiResponse<T> {\n  data: T;\n  success: boolean;\n  message?: string;\n}\n\n/**\n * Service to handle task API calls with status mapping between client and server\n */\nexport const TaskService = {\n  /**\n   * Get all tasks for a project\n   */\n  getAllTasks: async (projectId: string, token: string): Promise<Task[]> => {\n    try {\n      const response = await api.tasks.getAllTasks(projectId, token) as ApiResponse<any[]>;\n      \n      // Map the backend status to frontend status\n      return response.data.map((task: any) => ({\n        ...task,\n        status: mapToFrontendStatus(task.status)\n      }));\n    } catch (error) {\n      console.error('Error fetching tasks:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Add a comment to a task\n   */\n  addTaskComment: async (projectId: string, taskId: string, commentText: string, userId: string, token: string): Promise<any> => {\n    try {\n      // In a real implementation, this would call an API endpoint\n      // For now, we'll simulate it\n      const newComment = {\n        id: `comment-${Date.now()}`,\n        taskId,\n        text: commentText,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        author: {\n          id: userId,\n          firstName: 'Current',  // This would be populated from the API response\n          lastName: 'User'       // Same as above\n        }\n      };\n      \n      // Simulate API call delay\n      await new Promise(resolve => setTimeout(resolve, 500));\n      \n      console.log(`Added comment to task ${taskId}:`, newComment);\n      \n      return newComment;\n    } catch (error) {\n      console.error('Error adding comment:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Get all independent tasks (not associated with a project)\n   */\n  getAllIndependentTasks: async (token: string): Promise<Task[]> => {\n    try {\n      const response = await api.tasks.getAllIndependentTasks(token) as ApiResponse<any[]>;\n      \n      // Map the backend status to frontend status\n      return response.data.map((task: any) => ({\n        ...task,\n        status: mapToFrontendStatus(task.status)\n      }));\n    } catch (error) {\n      console.error('Error fetching independent tasks:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Get a specific task by ID\n   */\n  getTaskById: async (projectId: string, taskId: string, token: string): Promise<Task> => {\n    try {\n      const response = await api.tasks.getTaskById(projectId, taskId, token) as ApiResponse<any>;\n      \n      // Map the backend status to frontend status\n      return {\n        ...response.data,\n        status: mapToFrontendStatus(response.data.status)\n      };\n    } catch (error) {\n      console.error('Error fetching task:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Get a specific independent task by ID\n   */\n  getIndependentTaskById: async (taskId: string, token: string): Promise<Task> => {\n    try {\n      const response = await api.tasks.getIndependentTaskById(taskId, token) as ApiResponse<any>;\n      \n      // Map the backend status to frontend status\n      return {\n        ...response.data,\n        status: mapToFrontendStatus(response.data.status)\n      };\n    } catch (error) {\n      console.error('Error fetching independent task:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Create a new task in a project\n   */\n  createTask: async (projectId: string, taskData: Partial<Task>, token: string): Promise<Task> => {\n    try {\n      // Map the frontend status to backend status before sending\n      const backendTaskData = {\n        ...taskData,\n        status: mapToBackendStatus(taskData.status as TaskStatus)\n      };\n      \n      const response = await api.tasks.createTask(projectId, backendTaskData, token) as ApiResponse<any>;\n      \n      // Map the backend status back to frontend status in the response\n      return {\n        ...response.data,\n        status: mapToFrontendStatus(response.data.status)\n      };\n    } catch (error) {\n      console.error('Error creating task:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Create a new independent task (not associated with any project)\n   */\n  createIndependentTask: async (taskData: Partial<Task>, token: string): Promise<Task> => {\n    try {\n      // Map the frontend status to backend status before sending\n      const backendTaskData = {\n        ...taskData,\n        status: mapToBackendStatus(taskData.status as TaskStatus)\n      };\n      \n      const response = await api.tasks.createIndependentTask(backendTaskData, token) as ApiResponse<any>;\n      \n      // Map the backend status back to frontend status in the response\n      return {\n        ...response.data,\n        status: mapToFrontendStatus(response.data.status)\n      };\n    } catch (error) {\n      console.error('Error creating independent task:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Update an existing task\n   */\n  updateTask: async (projectId: string, taskId: string, taskData: Partial<Task>, token: string): Promise<Task> => {\n    try {\n      // Map the frontend status to backend status before sending\n      const backendTaskData = {\n        ...taskData,\n        status: taskData.status !== undefined ? mapToBackendStatus(taskData.status as TaskStatus) : undefined\n      };\n      \n      const response = await api.tasks.updateTask(projectId, taskId, backendTaskData, token) as ApiResponse<any>;\n      \n      // If the API returns the updated task, map the status back\n      if (response.data) {\n        return {\n          ...response.data,\n          status: mapToFrontendStatus(response.data.status)\n        };\n      }\n      \n      // If the API doesn't return the updated task, return the original with the updated fields\n      return {\n        ...taskData,\n        id: taskId,\n        projectId\n      } as Task;\n    } catch (error) {\n      console.error('Error updating task:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Update an existing independent task\n   */\n  updateIndependentTask: async (taskId: string, taskData: Partial<Task>, token: string): Promise<Task> => {\n    try {\n      // Map the frontend status to backend status before sending\n      const backendTaskData = {\n        ...taskData,\n        status: taskData.status !== undefined ? mapToBackendStatus(taskData.status as TaskStatus) : undefined\n      };\n      \n      const response = await api.tasks.updateIndependentTask(taskId, backendTaskData, token) as ApiResponse<any>;\n      \n      // If the API returns the updated task, map the status back\n      if (response.data) {\n        return {\n          ...response.data,\n          status: mapToFrontendStatus(response.data.status)\n        };\n      }\n      \n      // If the API doesn't return the updated task, return the original with the updated fields\n      return {\n        ...taskData,\n        id: taskId\n      } as Task;\n    } catch (error) {\n      console.error('Error updating independent task:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Delete a task\n   */\n  deleteTask: async (projectId: string, taskId: string, token: string): Promise<void> => {\n    try {\n      await api.tasks.deleteTask(projectId, taskId, token);\n    } catch (error) {\n      console.error('Error deleting task:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Delete an independent task\n   */\n  deleteIndependentTask: async (taskId: string, token: string): Promise<void> => {\n    try {\n      await api.tasks.deleteIndependentTask(taskId, token);\n    } catch (error) {\n      console.error('Error deleting independent task:', error);\n      throw error;\n    }\n  }\n}; "],"mappings":"AAAA,MAAO,CAAAA,GAAG,KAAM,OAAO,CAEvB,OAASC,kBAAkB,CAAEC,mBAAmB,KAAQ,2BAA2B,CAEnF;AAOA;AACA;AACA,GACA,MAAO,MAAM,CAAAC,WAAW,CAAG,CACzB;AACF;AACA,KACEC,WAAW,CAAE,KAAAA,CAAOC,SAAiB,CAAEC,KAAa,GAAsB,CACxE,GAAI,CACF,KAAM,CAAAC,QAAQ,CAAG,KAAM,CAAAP,GAAG,CAACQ,KAAK,CAACJ,WAAW,CAACC,SAAS,CAAEC,KAAK,CAAuB,CAEpF;AACA,MAAO,CAAAC,QAAQ,CAACE,IAAI,CAACC,GAAG,CAAEC,IAAS,GAAM,CACvC,GAAGA,IAAI,CACPC,MAAM,CAAEV,mBAAmB,CAACS,IAAI,CAACC,MAAM,CACzC,CAAC,CAAC,CAAC,CACL,CAAE,MAAOC,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,uBAAuB,CAAEA,KAAK,CAAC,CAC7C,KAAM,CAAAA,KAAK,CACb,CACF,CAAC,CAED;AACF;AACA,KACEE,cAAc,CAAE,KAAAA,CAAOV,SAAiB,CAAEW,MAAc,CAAEC,WAAmB,CAAEC,MAAc,CAAEZ,KAAa,GAAmB,CAC7H,GAAI,CACF;AACA;AACA,KAAM,CAAAa,UAAU,CAAG,CACjBC,EAAE,CAAE,WAAWC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,CAC3BN,MAAM,CACNO,IAAI,CAAEN,WAAW,CACjBO,SAAS,CAAE,GAAI,CAAAH,IAAI,CAAC,CAAC,CAACI,WAAW,CAAC,CAAC,CACnCC,SAAS,CAAE,GAAI,CAAAL,IAAI,CAAC,CAAC,CAACI,WAAW,CAAC,CAAC,CACnCE,MAAM,CAAE,CACNP,EAAE,CAAEF,MAAM,CACVU,SAAS,CAAE,SAAS,CAAG;AACvBC,QAAQ,CAAE,MAAa;AACzB,CACF,CAAC,CAED;AACA,KAAM,IAAI,CAAAC,OAAO,CAACC,OAAO,EAAIC,UAAU,CAACD,OAAO,CAAE,GAAG,CAAC,CAAC,CAEtDjB,OAAO,CAACmB,GAAG,CAAC,yBAAyBjB,MAAM,GAAG,CAAEG,UAAU,CAAC,CAE3D,MAAO,CAAAA,UAAU,CACnB,CAAE,MAAON,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,uBAAuB,CAAEA,KAAK,CAAC,CAC7C,KAAM,CAAAA,KAAK,CACb,CACF,CAAC,CAED;AACF;AACA,KACEqB,sBAAsB,CAAE,KAAO,CAAA5B,KAAa,EAAsB,CAChE,GAAI,CACF,KAAM,CAAAC,QAAQ,CAAG,KAAM,CAAAP,GAAG,CAACQ,KAAK,CAAC0B,sBAAsB,CAAC5B,KAAK,CAAuB,CAEpF;AACA,MAAO,CAAAC,QAAQ,CAACE,IAAI,CAACC,GAAG,CAAEC,IAAS,GAAM,CACvC,GAAGA,IAAI,CACPC,MAAM,CAAEV,mBAAmB,CAACS,IAAI,CAACC,MAAM,CACzC,CAAC,CAAC,CAAC,CACL,CAAE,MAAOC,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,mCAAmC,CAAEA,KAAK,CAAC,CACzD,KAAM,CAAAA,KAAK,CACb,CACF,CAAC,CAED;AACF;AACA,KACEsB,WAAW,CAAE,KAAAA,CAAO9B,SAAiB,CAAEW,MAAc,CAAEV,KAAa,GAAoB,CACtF,GAAI,CACF,KAAM,CAAAC,QAAQ,CAAG,KAAM,CAAAP,GAAG,CAACQ,KAAK,CAAC2B,WAAW,CAAC9B,SAAS,CAAEW,MAAM,CAAEV,KAAK,CAAqB,CAE1F;AACA,MAAO,CACL,GAAGC,QAAQ,CAACE,IAAI,CAChBG,MAAM,CAAEV,mBAAmB,CAACK,QAAQ,CAACE,IAAI,CAACG,MAAM,CAClD,CAAC,CACH,CAAE,MAAOC,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,sBAAsB,CAAEA,KAAK,CAAC,CAC5C,KAAM,CAAAA,KAAK,CACb,CACF,CAAC,CAED;AACF;AACA,KACEuB,sBAAsB,CAAE,KAAAA,CAAOpB,MAAc,CAAEV,KAAa,GAAoB,CAC9E,GAAI,CACF,KAAM,CAAAC,QAAQ,CAAG,KAAM,CAAAP,GAAG,CAACQ,KAAK,CAAC4B,sBAAsB,CAACpB,MAAM,CAAEV,KAAK,CAAqB,CAE1F;AACA,MAAO,CACL,GAAGC,QAAQ,CAACE,IAAI,CAChBG,MAAM,CAAEV,mBAAmB,CAACK,QAAQ,CAACE,IAAI,CAACG,MAAM,CAClD,CAAC,CACH,CAAE,MAAOC,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,kCAAkC,CAAEA,KAAK,CAAC,CACxD,KAAM,CAAAA,KAAK,CACb,CACF,CAAC,CAED;AACF;AACA,KACEwB,UAAU,CAAE,KAAAA,CAAOhC,SAAiB,CAAEiC,QAAuB,CAAEhC,KAAa,GAAoB,CAC9F,GAAI,CACF;AACA,KAAM,CAAAiC,eAAe,CAAG,CACtB,GAAGD,QAAQ,CACX1B,MAAM,CAAEX,kBAAkB,CAACqC,QAAQ,CAAC1B,MAAoB,CAC1D,CAAC,CAED,KAAM,CAAAL,QAAQ,CAAG,KAAM,CAAAP,GAAG,CAACQ,KAAK,CAAC6B,UAAU,CAAChC,SAAS,CAAEkC,eAAe,CAAEjC,KAAK,CAAqB,CAElG;AACA,MAAO,CACL,GAAGC,QAAQ,CAACE,IAAI,CAChBG,MAAM,CAAEV,mBAAmB,CAACK,QAAQ,CAACE,IAAI,CAACG,MAAM,CAClD,CAAC,CACH,CAAE,MAAOC,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,sBAAsB,CAAEA,KAAK,CAAC,CAC5C,KAAM,CAAAA,KAAK,CACb,CACF,CAAC,CAED;AACF;AACA,KACE2B,qBAAqB,CAAE,KAAAA,CAAOF,QAAuB,CAAEhC,KAAa,GAAoB,CACtF,GAAI,CACF;AACA,KAAM,CAAAiC,eAAe,CAAG,CACtB,GAAGD,QAAQ,CACX1B,MAAM,CAAEX,kBAAkB,CAACqC,QAAQ,CAAC1B,MAAoB,CAC1D,CAAC,CAED,KAAM,CAAAL,QAAQ,CAAG,KAAM,CAAAP,GAAG,CAACQ,KAAK,CAACgC,qBAAqB,CAACD,eAAe,CAAEjC,KAAK,CAAqB,CAElG;AACA,MAAO,CACL,GAAGC,QAAQ,CAACE,IAAI,CAChBG,MAAM,CAAEV,mBAAmB,CAACK,QAAQ,CAACE,IAAI,CAACG,MAAM,CAClD,CAAC,CACH,CAAE,MAAOC,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,kCAAkC,CAAEA,KAAK,CAAC,CACxD,KAAM,CAAAA,KAAK,CACb,CACF,CAAC,CAED;AACF;AACA,KACE4B,UAAU,CAAE,KAAAA,CAAOpC,SAAiB,CAAEW,MAAc,CAAEsB,QAAuB,CAAEhC,KAAa,GAAoB,CAC9G,GAAI,CACF;AACA,KAAM,CAAAiC,eAAe,CAAG,CACtB,GAAGD,QAAQ,CACX1B,MAAM,CAAE0B,QAAQ,CAAC1B,MAAM,GAAK8B,SAAS,CAAGzC,kBAAkB,CAACqC,QAAQ,CAAC1B,MAAoB,CAAC,CAAG8B,SAC9F,CAAC,CAED,KAAM,CAAAnC,QAAQ,CAAG,KAAM,CAAAP,GAAG,CAACQ,KAAK,CAACiC,UAAU,CAACpC,SAAS,CAAEW,MAAM,CAAEuB,eAAe,CAAEjC,KAAK,CAAqB,CAE1G;AACA,GAAIC,QAAQ,CAACE,IAAI,CAAE,CACjB,MAAO,CACL,GAAGF,QAAQ,CAACE,IAAI,CAChBG,MAAM,CAAEV,mBAAmB,CAACK,QAAQ,CAACE,IAAI,CAACG,MAAM,CAClD,CAAC,CACH,CAEA;AACA,MAAO,CACL,GAAG0B,QAAQ,CACXlB,EAAE,CAAEJ,MAAM,CACVX,SACF,CAAC,CACH,CAAE,MAAOQ,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,sBAAsB,CAAEA,KAAK,CAAC,CAC5C,KAAM,CAAAA,KAAK,CACb,CACF,CAAC,CAED;AACF;AACA,KACE8B,qBAAqB,CAAE,KAAAA,CAAO3B,MAAc,CAAEsB,QAAuB,CAAEhC,KAAa,GAAoB,CACtG,GAAI,CACF;AACA,KAAM,CAAAiC,eAAe,CAAG,CACtB,GAAGD,QAAQ,CACX1B,MAAM,CAAE0B,QAAQ,CAAC1B,MAAM,GAAK8B,SAAS,CAAGzC,kBAAkB,CAACqC,QAAQ,CAAC1B,MAAoB,CAAC,CAAG8B,SAC9F,CAAC,CAED,KAAM,CAAAnC,QAAQ,CAAG,KAAM,CAAAP,GAAG,CAACQ,KAAK,CAACmC,qBAAqB,CAAC3B,MAAM,CAAEuB,eAAe,CAAEjC,KAAK,CAAqB,CAE1G;AACA,GAAIC,QAAQ,CAACE,IAAI,CAAE,CACjB,MAAO,CACL,GAAGF,QAAQ,CAACE,IAAI,CAChBG,MAAM,CAAEV,mBAAmB,CAACK,QAAQ,CAACE,IAAI,CAACG,MAAM,CAClD,CAAC,CACH,CAEA;AACA,MAAO,CACL,GAAG0B,QAAQ,CACXlB,EAAE,CAAEJ,MACN,CAAC,CACH,CAAE,MAAOH,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,kCAAkC,CAAEA,KAAK,CAAC,CACxD,KAAM,CAAAA,KAAK,CACb,CACF,CAAC,CAED;AACF;AACA,KACE+B,UAAU,CAAE,KAAAA,CAAOvC,SAAiB,CAAEW,MAAc,CAAEV,KAAa,GAAoB,CACrF,GAAI,CACF,KAAM,CAAAN,GAAG,CAACQ,KAAK,CAACoC,UAAU,CAACvC,SAAS,CAAEW,MAAM,CAAEV,KAAK,CAAC,CACtD,CAAE,MAAOO,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,sBAAsB,CAAEA,KAAK,CAAC,CAC5C,KAAM,CAAAA,KAAK,CACb,CACF,CAAC,CAED;AACF;AACA,KACEgC,qBAAqB,CAAE,KAAAA,CAAO7B,MAAc,CAAEV,KAAa,GAAoB,CAC7E,GAAI,CACF,KAAM,CAAAN,GAAG,CAACQ,KAAK,CAACqC,qBAAqB,CAAC7B,MAAM,CAAEV,KAAK,CAAC,CACtD,CAAE,MAAOO,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,kCAAkC,CAAEA,KAAK,CAAC,CACxD,KAAM,CAAAA,KAAK,CACb,CACF,CACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}