{"ast":null,"code":"import api from './api';\nimport { mapToBackendStatus, mapToFrontendStatus } from '../utils/taskStatusMapper';\n\n// Define response interfaces\n\n/**\n * Service to handle task API calls with status mapping between client and server\n */\nexport const TaskService = {\n  /**\n   * Get all tasks for a project\n   */\n  getAllTasks: async (projectId, token) => {\n    try {\n      const response = await api.tasks.getAllTasks(projectId, token);\n\n      // Map the backend status to frontend status\n      return response.data.map(task => ({\n        ...task,\n        status: mapToFrontendStatus(task.status)\n      }));\n    } catch (error) {\n      console.error('Error fetching tasks:', error);\n      throw error;\n    }\n  },\n  /**\n   * Add a comment to a task\n   */\n  addTaskComment: async (projectId, taskId, commentText, userId, token) => {\n    try {\n      // In a real implementation, this would call an API endpoint\n      // For now, we'll simulate it\n      const newComment = {\n        id: `comment-${Date.now()}`,\n        taskId,\n        text: commentText,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        author: {\n          id: userId,\n          firstName: 'Current',\n          // This would be populated from the API response\n          lastName: 'User' // Same as above\n        }\n      };\n\n      // Simulate API call delay\n      await new Promise(resolve => setTimeout(resolve, 500));\n      console.log(`Added comment to task ${taskId}:`, newComment);\n      return newComment;\n    } catch (error) {\n      console.error('Error adding comment:', error);\n      throw error;\n    }\n  },\n  /**\n   * Get all independent tasks (not associated with a project)\n   */\n  getAllIndependentTasks: async token => {\n    try {\n      const response = await api.tasks.getAllIndependentTasks(token);\n\n      // Map the backend status to frontend status\n      return response.data.map(task => ({\n        ...task,\n        status: mapToFrontendStatus(task.status)\n      }));\n    } catch (error) {\n      console.error('Error fetching independent tasks:', error);\n      throw error;\n    }\n  },\n  /**\n   * Get a specific task by ID\n   */\n  getTaskById: async (projectId, taskId, token) => {\n    try {\n      const response = await api.tasks.getTaskById(projectId, taskId, token);\n\n      // Map the backend status to frontend status\n      return {\n        ...response.data,\n        status: mapToFrontendStatus(response.data.status)\n      };\n    } catch (error) {\n      console.error('Error fetching task:', error);\n      throw error;\n    }\n  },\n  /**\n   * Get a specific independent task by ID\n   */\n  getIndependentTaskById: async (taskId, token) => {\n    try {\n      const response = await api.tasks.getIndependentTaskById(taskId, token);\n\n      // Map the backend status to frontend status\n      return {\n        ...response.data,\n        status: mapToFrontendStatus(response.data.status)\n      };\n    } catch (error) {\n      console.error('Error fetching independent task:', error);\n      throw error;\n    }\n  },\n  /**\n   * Create a new task in a project\n   */\n  createTask: async (projectId, taskData, token) => {\n    try {\n      // Map the frontend status to backend status before sending\n      const backendTaskData = {\n        ...taskData,\n        status: mapToBackendStatus(taskData.status)\n      };\n      const response = await api.tasks.createTask(projectId, backendTaskData, token);\n\n      // Map the backend status back to frontend status in the response\n      return {\n        ...response.data,\n        status: mapToFrontendStatus(response.data.status)\n      };\n    } catch (error) {\n      console.error('Error creating task:', error);\n      throw error;\n    }\n  },\n  /**\n   * Create a new independent task (not associated with any project)\n   */\n  createIndependentTask: async (taskData, token) => {\n    try {\n      // Map the frontend status to backend status before sending\n      const backendTaskData = {\n        ...taskData,\n        status: mapToBackendStatus(taskData.status)\n      };\n      const response = await api.tasks.createIndependentTask(backendTaskData, token);\n\n      // Map the backend status back to frontend status in the response\n      return {\n        ...response.data,\n        status: mapToFrontendStatus(response.data.status)\n      };\n    } catch (error) {\n      console.error('Error creating independent task:', error);\n      throw error;\n    }\n  },\n  /**\n   * Update an existing task\n   */\n  updateTask: async (projectId, taskId, taskData, token) => {\n    try {\n      // Map the frontend status to backend status before sending\n      const backendTaskData = {\n        ...taskData,\n        status: taskData.status !== undefined ? mapToBackendStatus(taskData.status) : undefined\n      };\n      const response = await api.tasks.updateTask(projectId, taskId, backendTaskData, token);\n\n      // If the API returns the updated task, map the status back\n      if (response.data) {\n        return {\n          ...response.data,\n          status: mapToFrontendStatus(response.data.status)\n        };\n      }\n\n      // If the API doesn't return the updated task, return the original with the updated fields\n      return {\n        ...taskData,\n        id: taskId,\n        projectId\n      };\n    } catch (error) {\n      console.error('Error updating task:', error);\n      throw error;\n    }\n  },\n  /**\n   * Update an existing independent task\n   */\n  updateIndependentTask: async (taskId, taskData, token) => {\n    try {\n      // Map the frontend status to backend status before sending\n      const backendTaskData = {\n        ...taskData,\n        status: taskData.status !== undefined ? mapToBackendStatus(taskData.status) : undefined\n      };\n      const response = await api.tasks.updateIndependentTask(taskId, backendTaskData, token);\n\n      // If the API returns the updated task, map the status back\n      if (response.data) {\n        return {\n          ...response.data,\n          status: mapToFrontendStatus(response.data.status)\n        };\n      }\n\n      // If the API doesn't return the updated task, return the original with the updated fields\n      return {\n        ...taskData,\n        id: taskId\n      };\n    } catch (error) {\n      console.error('Error updating independent task:', error);\n      throw error;\n    }\n  },\n  /**\n   * Delete a task\n   */\n  deleteTask: async (projectId, taskId, token) => {\n    try {\n      await api.tasks.deleteTask(projectId, taskId, token);\n    } catch (error) {\n      console.error('Error deleting task:', error);\n      throw error;\n    }\n  },\n  /**\n   * Delete an independent task\n   */\n  deleteIndependentTask: async (taskId, token) => {\n    try {\n      await api.tasks.deleteIndependentTask(taskId, token);\n    } catch (error) {\n      console.error('Error deleting independent task:', error);\n      throw error;\n    }\n  }\n};","map":{"version":3,"names":["api","mapToBackendStatus","mapToFrontendStatus","TaskService","getAllTasks","projectId","token","response","tasks","data","map","task","status","error","console","addTaskComment","taskId","commentText","userId","newComment","id","Date","now","text","createdAt","toISOString","updatedAt","author","firstName","lastName","Promise","resolve","setTimeout","log","getAllIndependentTasks","getTaskById","getIndependentTaskById","createTask","taskData","backendTaskData","createIndependentTask","updateTask","undefined","updateIndependentTask","deleteTask","deleteIndependentTask"],"sources":["/Users/hassanalsahli/Desktop/Themis/themis-client-final/src/services/TaskService.ts"],"sourcesContent":["import api from './api';\nimport { Task, TaskStatus } from '../types';\nimport { mapToBackendStatus, mapToFrontendStatus } from '../utils/taskStatusMapper';\n\n// Define response interfaces\ninterface ApiResponse<T> {\n  data: T;\n  success: boolean;\n  message?: string;\n}\n\n/**\n * Service to handle task API calls with status mapping between client and server\n */\nexport const TaskService = {\n  /**\n   * Get all tasks for a project\n   */\n  getAllTasks: async (projectId: string, token: string): Promise<Task[]> => {\n    try {\n      const response = await api.tasks.getAllTasks(projectId, token) as ApiResponse<any[]>;\n      \n      // Map the backend status to frontend status\n      return response.data.map((task: any) => ({\n        ...task,\n        status: mapToFrontendStatus(task.status)\n      }));\n    } catch (error) {\n      console.error('Error fetching tasks:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Add a comment to a task\n   */\n  addTaskComment: async (projectId: string, taskId: string, commentText: string, userId: string, token: string): Promise<any> => {\n    try {\n      // In a real implementation, this would call an API endpoint\n      // For now, we'll simulate it\n      const newComment = {\n        id: `comment-${Date.now()}`,\n        taskId,\n        text: commentText,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        author: {\n          id: userId,\n          firstName: 'Current',  // This would be populated from the API response\n          lastName: 'User'       // Same as above\n        }\n      };\n      \n      // Simulate API call delay\n      await new Promise(resolve => setTimeout(resolve, 500));\n      \n      console.log(`Added comment to task ${taskId}:`, newComment);\n      \n      return newComment;\n    } catch (error) {\n      console.error('Error adding comment:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Get all independent tasks (not associated with a project)\n   */\n  getAllIndependentTasks: async (token: string): Promise<Task[]> => {\n    try {\n      const response = await api.tasks.getAllIndependentTasks(token) as ApiResponse<any[]>;\n      \n      // Map the backend status to frontend status\n      return response.data.map((task: any) => ({\n        ...task,\n        status: mapToFrontendStatus(task.status)\n      }));\n    } catch (error) {\n      console.error('Error fetching independent tasks:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Get a specific task by ID\n   */\n  getTaskById: async (projectId: string, taskId: string, token: string): Promise<Task> => {\n    try {\n      const response = await api.tasks.getTaskById(projectId, taskId, token) as ApiResponse<any>;\n      \n      // Map the backend status to frontend status\n      return {\n        ...response.data,\n        status: mapToFrontendStatus(response.data.status)\n      };\n    } catch (error) {\n      console.error('Error fetching task:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Get a specific independent task by ID\n   */\n  getIndependentTaskById: async (taskId: string, token: string): Promise<Task> => {\n    try {\n      const response = await api.tasks.getIndependentTaskById(taskId, token) as ApiResponse<any>;\n      \n      // Map the backend status to frontend status\n      return {\n        ...response.data,\n        status: mapToFrontendStatus(response.data.status)\n      };\n    } catch (error) {\n      console.error('Error fetching independent task:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Create a new task in a project\n   */\n  createTask: async (projectId: string, taskData: Partial<Task>, token: string): Promise<Task> => {\n    try {\n      // Map the frontend status to backend status before sending\n      const backendTaskData = {\n        ...taskData,\n        status: mapToBackendStatus(taskData.status as TaskStatus)\n      };\n      \n      const response = await api.tasks.createTask(projectId, backendTaskData, token) as ApiResponse<any>;\n      \n      // Map the backend status back to frontend status in the response\n      return {\n        ...response.data,\n        status: mapToFrontendStatus(response.data.status)\n      };\n    } catch (error) {\n      console.error('Error creating task:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Create a new independent task (not associated with any project)\n   */\n  createIndependentTask: async (taskData: Partial<Task>, token: string): Promise<Task> => {\n    try {\n      // Map the frontend status to backend status before sending\n      const backendTaskData = {\n        ...taskData,\n        status: mapToBackendStatus(taskData.status as TaskStatus)\n      };\n      \n      const response = await api.tasks.createIndependentTask(backendTaskData, token) as ApiResponse<any>;\n      \n      // Map the backend status back to frontend status in the response\n      return {\n        ...response.data,\n        status: mapToFrontendStatus(response.data.status)\n      };\n    } catch (error) {\n      console.error('Error creating independent task:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Update an existing task\n   */\n  updateTask: async (projectId: string, taskId: string, taskData: Partial<Task>, token: string): Promise<Task> => {\n    try {\n      // Map the frontend status to backend status before sending\n      const backendTaskData = {\n        ...taskData,\n        status: taskData.status !== undefined ? mapToBackendStatus(taskData.status as TaskStatus) : undefined\n      };\n      \n      const response = await api.tasks.updateTask(projectId, taskId, backendTaskData, token) as ApiResponse<any>;\n      \n      // If the API returns the updated task, map the status back\n      if (response.data) {\n        return {\n          ...response.data,\n          status: mapToFrontendStatus(response.data.status)\n        };\n      }\n      \n      // If the API doesn't return the updated task, return the original with the updated fields\n      return {\n        ...taskData,\n        id: taskId,\n        projectId\n      } as Task;\n    } catch (error) {\n      console.error('Error updating task:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Update an existing independent task\n   */\n  updateIndependentTask: async (taskId: string, taskData: Partial<Task>, token: string): Promise<Task> => {\n    try {\n      // Map the frontend status to backend status before sending\n      const backendTaskData = {\n        ...taskData,\n        status: taskData.status !== undefined ? mapToBackendStatus(taskData.status as TaskStatus) : undefined\n      };\n      \n      const response = await api.tasks.updateIndependentTask(taskId, backendTaskData, token) as ApiResponse<any>;\n      \n      // If the API returns the updated task, map the status back\n      if (response.data) {\n        return {\n          ...response.data,\n          status: mapToFrontendStatus(response.data.status)\n        };\n      }\n      \n      // If the API doesn't return the updated task, return the original with the updated fields\n      return {\n        ...taskData,\n        id: taskId\n      } as Task;\n    } catch (error) {\n      console.error('Error updating independent task:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Delete a task\n   */\n  deleteTask: async (projectId: string, taskId: string, token: string): Promise<void> => {\n    try {\n      await api.tasks.deleteTask(projectId, taskId, token);\n    } catch (error) {\n      console.error('Error deleting task:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Delete an independent task\n   */\n  deleteIndependentTask: async (taskId: string, token: string): Promise<void> => {\n    try {\n      await api.tasks.deleteIndependentTask(taskId, token);\n    } catch (error) {\n      console.error('Error deleting independent task:', error);\n      throw error;\n    }\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}